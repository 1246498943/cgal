namespace CGAL {
/*!
\example Classification/gis_tutorial_example.cpp
*/

/*!

\page tuto_gis GIS (Geographic Information System)
\cgalAutoToc

\author Simon Giraudot

Many sensors used in GIS applications (for example LIDAR), generate
dense point clouds. Such applications often take advantage of more
advanced data structure: for example, Triangulated Irregular Networks
(TIN) that can be the basis for Digital Surface Modeling (DSM) and for
the generation of Digital Elevation Modeling (DEM). Point clouds can
also be enriched by classification information that segments the
points into a set of semantic labels.

\section TutorialGIS_TIN TIN (Triangulated Irregular Network)

\cgal provides several triangulation data structures and algorithms. A
TIN can be generated by combining the 2D Delaunay %Triangulation with
projection traits: the triangulation structure is computed using the
2D positions of the points along a selected plane (usually, the
XY-plane), while the 3D positions of the points are kept for
visualization and measurements.

A TIN data structure can thus simply be defined the following way:

\snippet Classification/gis_tutorial_example.cpp TIN DS

Point clouds in many formats (XYZ, OFF, PLY, LAS) can be easily loaded
into a `CGAL::Point_set_3` structure, using the stream
operator. Generating the TIN is then straightforward:

\snippet Classification/gis_tutorial_example.cpp Init TIN

Because the Delaunay %Triangulation of \cgal is a model of `FaceGraph`,
the generated TIN can easily be converted into a mesh structure such
as `CGAL::Surface_mesh` and be saved into whatever formats are
supported by such structure:

\snippet Classification/gis_tutorial_example.cpp Save TIN

An example of a TIN computed this way on the San Fransisco data set
(see \ref TutorialGIS_Reference) is given on Figure
\cgalFigureRef{TutorialGISFigTIN}.

\cgalFigureBegin{TutorialGISFigTIN, tin.jpg}
Input point cloud and output TIN.
\cgalFigureEnd


\section TutorialGIS_DEM DEM (Digital Elevation Modeling)

The generated TIN is a first step in Digital Surface Modeling. A
standard procedure is to compute a Digital Elevation Modeling, that is
to say a representation of the ground as another TIN after filtering
non-ground points.

We propose, as an example, a simple DEM estimation decomposed in the
following steps:

1. Thresholding the height of the facets to remove brutal changes of
elevation
2. Clustering the other facets into connected components
3. Filtering all components smaller than a user-defined threshold

This algorithm relies on 2 parameters: a height threshold that
corresponds to the minimum height of a building, and a perimeter
threshold that corresponds to the maximum size of a building on the 2D
projection.

\subsection TutorialGIS_DEM_info TIN with info

Because it takes advantage of the flexible \cgal Delaunay
%Triangulation API, our TIN can be enriched with information on
vertices and/or on faces. In our case, each vertex keeps track of the
index of the corresponding point in the input point cloud (which will
allow to filter ground points afterwards), and each face is given the
index of its connected component.

\snippet Classification/gis_tutorial_example.cpp TIN_with_info

\subsection TutorialGIS_DEM_components Identifying connected components

Connected components are identified through a flooding algorithm: from
a seed face, all incident faces are inserted in the current connected
component unless their heights exceed the user-defined threshold.

\snippet Classification/gis_tutorial_example.cpp Components

This TIN enriched with connected component information can be saved as
a colored mesh:

\snippet Classification/gis_tutorial_example.cpp Save TIN with info

An example of a TIN colored by connected components is
given on Figure \cgalFigureRef{TutorialGISFigComponents}.

\cgalFigureBegin{TutorialGISFigComponents, components.jpg}
TIN colored by connected components. Faces above height threshold are
not assigned to any component and are displayed in gray.
\cgalFigureEnd

\subsection TutorialGIS_DEM_filtering Filtering

Components smaller than the largest building can be easily removed:

\snippet Classification/gis_tutorial_example.cpp Filtering

An example of a DEM computed with the described algorithm is given on
Figure \cgalFigureRef{TutorialGISFigDEM}.

\cgalFigureBegin{TutorialGISFigDEM, dem.jpg}
Simple Digital Elevation Model.
\cgalFigureEnd


\section TutorialGIS_Raster Rastering

The TIN data structure can be combined with barycentric coordinates in
order to interpolate and thus rasterize at any resolution needed the
information embedded in the vertices.

The following snippet generates a raster image of the height in the
form of rainbow ramp PPM file (simple bitmap format):

\snippet Classification/gis_tutorial_example.cpp Rastering

An example of a raster image with a rainbow ramp representing height
is given on Figure \cgalFigureRef{TutorialGISFigRastering}.

\cgalFigureBegin{TutorialGISFigRastering, raster.jpg}
Raster visualisation of height using a rainbow ramp, ranging from
light blue for low values to dark red for high values.
\cgalFigureEnd

\section TutorialGIS_Contour Contouring

Extracting isolevels of a function defined on a TIN is another
application that can be done with \cgal. We demonstrate here how to
extract isolevels of height to build a topographic map.

\subsection TutorialGIS_Contour_Extraction Building Contour Graph

The first step is to extract, from all faces of the triangulation, the
section of each isolevel that goes through that face, in the form of a
segment. The following functions allow to test if one isovalue does
cross a face, and to extract it then:

\snippet Classification/gis_tutorial_example.cpp Contouring functions

From these functions, we can create a graph of segments to process
later into a set of polylines. To do so, we use the
`boost::adjacency_list` structure from boost and keep track of a
mapping from the positions of the end points to the vertices of the
graph.

The following code computes 50 isovalues evenly distributed between
the minimum and maximum heights of the point cloud and creates a graph
containing all isolevels:

\snippet Classification/gis_tutorial_example.cpp Contouring extraction

\subsection TutorialGIS_Contour_Splitting Splitting Into Polylines

Once the graph is created, splitting it into polylines is easily
performed using the function `split_graph_into_polylines()`:

\snippet Classification/gis_tutorial_example.cpp Contouring split

This function requires a visitor which is called when starting a
polyline, when adding a point to it and when ending it. Defining such
a class is straightforward in our case:

\snippet Classification/gis_tutorial_example.cpp Contouring visitor

An example of contouring using 50 isovalues is given on Figure
\cgalFigureRef{TutorialGISFigContour}.

\cgalFigureBegin{TutorialGISFigContour, contour.jpg}
Contouring using 50 isovalues evenly spaced.
\cgalFigureEnd

\subsection TutorialGIS_Contour_Simplifying Simplifying

Because the output is quite noisy, users may want to simplify the
polylines. \cgal provides a polyline simplification algorithm that
guarantees that two polylines won't intersect after
simplification. This algorithm takes advantage of the Constrained
Delaunay %Triangulation 2 Plus, which embeds polylines as a set of
constraints:

\snippet Classification/gis_tutorial_example.cpp CDT

The following code simplifies the polyline set based on the squared
distance to the original polylines, stopping when no more vertex can
be removed without going farther than 4 times the average spacing.

\snippet Classification/gis_tutorial_example.cpp Contouring simplify

An example of simplified contouring is given on Figure
\cgalFigureRef{TutorialGISFigSimplified}.

\cgalFigureBegin{TutorialGISFigSimplified, contour_simplified.jpg}
Simplified contour which only uses less than 2\% of the original
vertices.
\cgalFigureEnd

\section TutorialGIS_Classify Classifying

\cgal provides a %Classification package which can be used to segment a
point cloud into a user-defined label set. The state-of-the-art
classifier currently available in \cgal is the %Random Forest from
ETHZ. As it is a supervised classifier, a training set is needed.

The following snippet shows how to use some manually selected training
set to train a %Random Forest classifier and compute a classification
regularized by a Graph Cut algorithm:

\snippet Classification/gis_tutorial_example.cpp Classification

An example of training set and resulting classification is given on
Figure \cgalFigureRef{TutorialGISFigClassif}.

\cgalFigureBegin{TutorialGISFigClassif, classif_tuto.jpg}
Top: a slice of the point cloud classified by hand. Bottom: a
classification regularized by Graph Cut after training on 3 manually
classified slices.
\cgalFigureEnd

\section TutorialGIS_Code Full Code Example

All the code snippets used in this tutorial can be assembled to create
a full GIS pipeline (provided the correct _includes_ are
used). We give a full code example which achieves all the steps
described in this tutorial.

\include Classification/gis_tutorial_example.cpp

\section TutorialGIS_Reference References

This tutorial was based on the following \cgal packages:

- \ref PkgTriangulation2Ref
- \ref PkgPointSet3Ref
- \ref PkgPointSetProcessing3Ref
- \ref PkgSurface_mesh
- \ref PkgBGLRef
- \ref PkgPolygonMeshProcessingRef
- \ref PkgPolylineSimplification2Ref
- \ref PkgClassificationRef

The data set used throughout this tutorial comes from the
https://www.usgs.gov/ database, licensed under the _US Government
Public Domain_.

*/
}
